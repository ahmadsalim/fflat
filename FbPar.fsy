%{
 (* 
    Parsing specification for Fb programming language
    Original Author: Peter Sestoft <sestoft@itu.dk> (for the the microML programming language)
  *)

 open FbAst;
%}

%token <int> CSTINT
%token <string> NAME
%token <bool> CSTBOOL

%token ELSE END FALSE IF IN LET NOT THEN TRUE AND
%token FUN ARROW
%token PLUS MINUS TIMES DIV MOD
%token EQ NE GT LT GE LE
%token LPAR RPAR 
%token EOF

%right ARROW
%left ELSE              /* lowest precedence  */
%left EQ NE 
%nonassoc GT LT GE LE
%left PLUS MINUS
%left TIMES DIV MOD 
%nonassoc NOT           /* highest precedence  */

%start Main
%type <FbAst.expr> Main Expr AtExpr Const
%type <FbAst.expr> AppExpr

%%

Main:
    Expr EOF                            { $1 }
;

ArgList:
    NAME								{ $1::[] }
  |	NAME ArgList                        { $1::$2 }

Expr:
    AtExpr                              { $1                        }
  | AppExpr                             { $1                        }
  | FUN ArgList ARROW Expr              { mkFun $2 $4               }
  | IF Expr THEN Expr ELSE Expr         { If($2, $4, $6)            }
  | MINUS Expr                          { Prim("-", Cst(Int 0), $2) }
  | Expr PLUS  Expr                     { Prim("+",  $1, $3)        }
  | Expr MINUS Expr                     { Prim("-",  $1, $3)        }
  | Expr TIMES Expr                     { Prim("*",  $1, $3)        }
  | Expr DIV   Expr                     { Prim("/",  $1, $3)        } 
  | Expr MOD   Expr                     { Prim("%",  $1, $3)        }
  | Expr EQ    Expr                     { Prim("=",  $1, $3)        }
  | Expr NE    Expr                     { Prim("<>", $1, $3)        }
  | Expr GT    Expr                     { Prim(">",  $1, $3)        }
  | Expr LT    Expr                     { Prim("<",  $1, $3)        }
  | Expr GE    Expr                     { Prim(">=", $1, $3)        }
  | Expr LE    Expr                     { Prim("<=", $1, $3)        }
;

FunBinding:
    | NAME ArgList EQ Expr              { mkLetfun $1 $2 $4      }
;

FunBindings:
    | FunBinding                        { $1::[]                 }
    | FunBinding AND FunBindings	    { $1::$3                 }
;

AtExpr:
    Const                               { $1                     }
  | NAME                                { Var $1                 }
  | LET NAME EQ Expr IN Expr END        { Let($2, $4, $6)        }
  | LET FunBindings IN Expr END         { Letfuns($2, $4)        }
  | LPAR Expr RPAR                      { $2                     }
;

AppExpr:
    AtExpr AtExpr                       { Call($1, $2)           }
  | AppExpr AtExpr                      { Call($1, $2)           }
;

Const:
    CSTINT                              { Cst(Int($1))           }
  | CSTBOOL                             { Cst(Bool($1))          }
;
