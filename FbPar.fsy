%{
 (* 
    Parsing specification for Fb programming language
    Original Author: Peter Sestoft <sestoft@itu.dk> (for the the microML programming language)
  *)

 open FbAst;
%}

%token <int> CstInt_t
%token <bool> CstBool_t
%token <string> CstStr_t
%token <string * string> StrdLit_t
%token <string> Name_t

%token Else_t End_t If_t In_t Let_t Not_t Then_t And_t Hat_t
%token Fun_t Arrow_t
%token Plus_t Minus_t Times_t Div_t Mod_t
%token Eq_t Ne_t Gt_t Lt_t Ge_t Le_t
%token LPar_t RPar_t Comma_t
%token Eof_t

%right Arrow_t
%left Else_t              /* lowest precedence  */
%left Eq_t Ne_t 
%nonassoc Gt_t Lt_t Ge_t Le_t
%left Plus_t Minus_t
%left Hat_t
%left Times_t Div_t Mod_t 
%nonassoc Not_t           /* highest precedence  */

%start Main
%type <FbAst.expr> Main Expr AtExpr Const
%type <FbAst.expr> AppExpr

%%

Main:
    Expr Eof_t                            { $1 }
;

ArgList:
    Name_t								{ $1::[] }
  |	Name_t ArgList                      { $1::$2 }

Expr:
    AtExpr                              { $1                        }
  | AppExpr                             { $1                        }
  | Fun_t ArgList Arrow_t Expr          { mkFun $2 $4               }
  | If_t Expr Then_t Expr Else_t Expr   { If($2, $4, $6)            }
  | Minus_t Expr                        { Prim("-", Cst(Int 0), $2) }
  | Expr Plus_t  Expr                   { Prim("+",  $1, $3)        }
  | Expr Minus_t Expr                   { Prim("-",  $1, $3)        }
  | Expr Times_t Expr                   { Prim("*",  $1, $3)        }
  | Expr Div_t   Expr                   { Prim("/",  $1, $3)        } 
  | Expr Mod_t   Expr                   { Prim("%",  $1, $3)        }
  | Expr Eq_t    Expr                   { Prim("=",  $1, $3)        }
  | Expr Ne_t    Expr                   { Prim("<>", $1, $3)        }
  | Expr Gt_t    Expr                   { Prim(">",  $1, $3)        }
  | Expr Lt_t    Expr                   { Prim("<",  $1, $3)        }
  | Expr Ge_t    Expr                   { Prim(">=", $1, $3)        }
  | Expr Le_t    Expr                   { Prim("<=", $1, $3)        }
  | Expr Hat_t   Expr                   { Prim("^",  $1, $3)        }
  | StrdLit_t                           { StrdLit $1                }
;

FunBinding:
  | Name_t ArgList Eq_t Expr              { mkLetfun $1 $2 $4      }
;

FunBindings:
  | FunBinding                          { $1::[]                 }
  | FunBinding And_t FunBindings	    { $1::$3                 }
;

AtExpr:
    Const                                  { $1                     }
  | Name_t                                 { Var $1                 }
  | Let_t Name_t Eq_t Expr In_t Expr End_t { Let($2, $4, $6)        }
  | Let_t FunBindings In_t Expr End_t      { Letfuns($2, $4)        }
  | LPar_t Expr RPar_t                     { $2                     }
;

AppExpr:
  | AtExpr AtExpr                       { Call($1, $2)           }
  | AppExpr AtExpr                      { Call($1, $2)           }
;

Const:
  | CstInt_t                            { Cst(Int($1))           }
  | CstBool_t                           { Cst(Bool($1))          }
  | CstStr_t                            { Cst(Str($1))           }
;
