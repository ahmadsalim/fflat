{
 (* 
    Lexer specification for Fb programming language
    Original Author: Peter Sestoft <sestoft@itu.dk> (for the the microML programming language)
  *)

module FbLex

open Microsoft.FSharp.Text.Lexing
open FbPar;

let lexemeAsString lexbuf = 
    LexBuffer<char>.LexemeString lexbuf



(* Start of outermost comment currently being scanned *)
let commentStart = ref Position.Empty;  
 
let commentDepth = ref 0;  (* Current comment nesting *)

let getType (str:string) = str.Substring(1, str.Length - 2)

let escapeChar c =
    match c with
    | '\\' -> "\\"
    | 'n'  -> "\n"
    | 'r'  -> "\r"
    | 't'  -> "\t"
    | 'f'  -> "\f"
    | '\"'  -> "\""
    | _    -> failwithf "Lexer error: Unknow escape %A character in string" c

(* Distinguish keywords from identifiers: *)

let keyword (s:string) =
    match s.Trim() with
      | "else"  -> ELSE 
      | "end"   -> END
      | "false" -> CSTBOOL false
      | "if"    -> IF
      | "in"    -> IN
      | "let"   -> LET
      | "not"   -> NOT
      | "then"  -> THEN
      | "true"  -> CSTBOOL true
      | "fun"   -> FUN
      | "and"   -> AND
      | _       -> NAME (s.Trim())
}

let whitespace = ['\t' ' ']

rule Token = parse
  | '\r'                      { Token lexbuf }
  | '\n'                                   
                              { lexbuf.EndPos <- lexbuf.EndPos.NextLine; Token lexbuf }
  | whitespace* ['0'-'9']+    { CSTINT (System.Int32.Parse (lexemeAsString lexbuf)) }
  | whitespace* ['a'-'z''A'-'Z']['a'-'z''A'-'Z''0'-'9']*
                              { keyword (lexemeAsString lexbuf) }
  | whitespace* "(*"          { commentStart := lexbuf.StartPos;
                                commentDepth := 1; 
                                SkipComment lexbuf; 
                                Token lexbuf 
                              }
  | whitespace* "\""          { ParseString (System.Text.StringBuilder()) lexbuf }
  | whitespace* '%' ['a'-'z']+ '{'
                              { ParseStrdLit (getType (lexemeAsString lexbuf))
                                                (System.Text.StringBuilder()) lexbuf }
  | whitespace* '='           { EQ }
  | whitespace* "<>"          { NE }
  | whitespace* '>'           { GT }
  | whitespace* '<'           { LT }
  | whitespace* ">="          { GE }
  | whitespace* "<="          { LE }
  | whitespace* '+'           { PLUS }                     
  | whitespace* '-'           { MINUS }                     
  | whitespace* '*'           { TIMES }                     
  | whitespace* '/'           { DIV }                     
  | whitespace* '%'           { MOD }
  | whitespace* '('           { LPAR }
  | whitespace* ')'           { RPAR }
  | whitespace* '^'           { HAT }
  | whitespace* "->"          { ARROW }
  | whitespace* eof           { EOF }
  | whitespace+               { Token lexbuf }
  | _                         { failwith "Lexer error: illegal symbol" }

and SkipComment = parse
    "*)"            { commentDepth := !commentDepth - 1;  
                      if !commentDepth = 0 then ()
                      else SkipComment lexbuf 
                    } 
   | "(*"           { commentDepth := !commentDepth + 1; 
                      SkipComment lexbuf }
   | eof            { failwith "Lexer error: unterminated comment" }
   | _              { SkipComment lexbuf }

and ParseString currStr = parse
   | "\""
                    { CSTSTR (currStr.ToString()) }
   | eof            { failwith "Lexer error: unterminated string"   }
   | "\\" _         { ignore <| currStr.Append(escapeChar (lexbuf.LexemeChar 1)); 
                      ParseString currStr lexbuf
                    }
   | _              { ignore <| currStr.Append(lexemeAsString lexbuf);
                      ParseString currStr lexbuf
                    }
and ParseStrdLit t currStr = parse
   | "{{"           { ignore <| currStr.Append("{");
                      ParseStrdLit t currStr lexbuf  
                    }
   | "}}"           { ignore <| currStr.Append("}");
                      ParseStrdLit t currStr lexbuf  
                    }
   | "}"
                    { STRDLIT(t, currStr.ToString()) }
   | "{"            { failwith "Lexer error: unexpected unescaped { in data literal" }
   | _              { ignore <| currStr.Append(lexemeAsString lexbuf);
                      ParseStrdLit t currStr lexbuf
                    }